#=
This script performs a linear regression on the processed experimental data to determine
zero-order reaction rates for nitrate reduction. It reads the processed data for each
sample from the `data/exp_pro` directory, which should have been generated by the
`reading_processing_plotting_raw_data.jl` script.

The main steps of the script are:
1.  **Load Data**: It loads sample information and individual sample data from CSV files.
    The sample information is combined from two separate files (`sample_info.csv` and `sample_info_part2.csv`).
2.  **Data Correction**: For each sample, it corrects the concentration data for the volume
    of water removed during sampling. This provides a more accurate representation of the
    concentration in the batch reactor over time.
3.  **Identify Zero-Order Phase**: It identifies the time (`t_change`) at which the reaction
    is assumed to become zero-order. This is determined by finding when the DOC (Dissolved
    Organic Carbon) concentration becomes constant.
4.  **Linear Regression**: It performs a linear regression on the nitrate concentration data
    for the time period after `t_change` to calculate the zero-order reaction rate (`r_no3`).
5.  **Calculate Parameters**: It calculates several other parameters, including the initial
    concentration of the model (`c0_model`), the R² value of the fit, and the integral of
    the nitrate concentration over time.
6.  **Sulfate Analysis**: For samples from experiment 'B', it also analyzes sulfate data,
    calculating the rate of sulfate reduction.
7.  **Save Results**: The calculated parameters for all samples are saved to a CSV file
    at `data/exp_pro/linear_regression_params_v2.csv`.
8.  **Generate Plots**: It generates grid plots summarizing the fits for each sample, showing
    the raw data, the modeled zero-order decay, and the DOC data. These plots are saved
    in the `plots` directory in both PNG and PDF formats.

The script produces:
- A CSV file with the results of the linear regression for each sample.
- A series of grid plots visualizing the data and model fits.
=#

using DrWatson
@quickactivate "AmmerBatch"
using Roots
using DataFrames, CSV
using Statistics
using CairoMakie
using DataInterpolations
using QuadGK
using XLSX

colors = [:steelblue, :darkseagreen, :crimson]
meas_names = ["NO3-", "DOC", "SO4-2"]

# Part 1:
Vw = 0.08 # L: initial water volume in the batch
df_info = CSV.read(datadir("exp_pro","sample_info.csv"), DataFrame)
df_info_p2 = CSV.read(datadir("exp_pro","sample_info_part2.csv"), DataFrame)
# join the two dataframes
df_info = vcat(df_info, df_info_p2)
late_times_params = DataFrame(sample = String[], facies = String[], r_no3 = Float64[], c₀ = Float64[], R² = Float64[], t_zeroorder = Float64[],
                              integral_no3 = Float64[], c_quick = Float64[], t_quick = Float64[],
                              weight = Float64[], TOC = Union{Missing, Float64}[], S_tot = Union{Missing, Float64}[],
                              c₀so4 = Union{Missing, Float64}[], r_so4 = Union{Missing, Float64}[],
                              R²so4 = Union{Missing, Float64}[],
                              decrease_125 = Float64[], decrease_pct_125 = Float64[],
                              doc_decrease_125 = Float64[], doc_decrease_pct_125 = Float64[])
samples = df_info[!, :Sample]

# Collection to store corrected data for Excel export
data_for_excel = Vector{Pair{String, DataFrame}}()
# Collection to store corrected data aggregated by facies for Excel export
facies_data_collection = Dict{String, DataFrame}()

# Besides a grapth for each integration I want to add the axis to larger grid plots (according to size of the number of plots there may be more than on plot)
grid_plots = cld(length(samples), 8)
inch = 96
pt = 4/3
cm = inch / 2.54

grid_plot_figs = [Figure(size=(18cm, 27cm)) for _ in 1:grid_plots]
total_plots = length(samples)

# Figures 2 and 3 of the Manuscript, which are grouped by facies for each experiment:
figure_A = Figure(backgroundcolor = :transparent)
figure_B = Figure(backgroundcolor = :transparent)

# Identify unique facies for each experiment
exp_A_samples = df_info[startswith.(df_info.Sample, "A"), :]
exp_B_samples = df_info[startswith.(df_info.Sample, "B"), :]
# Merge C1 and C2 for Exp A
exp_A_samples.Facies = replace(exp_A_samples.Facies, "C2" => "C1")
unique_facies_A = sort(unique(exp_A_samples[!, "Facies new"]))
unique_facies_B = sort(unique(exp_B_samples[!, "Facies new"]))

letters = 'a':'z'
fontcolor = "#474747"

# Helper to create axes dict
function create_facies_axes(fig, u_facies, letters, experiment)
    axes = Dict()
    for (i, f) in enumerate(u_facies)
        row = cld(i, 2)
        col = (i-1)%2 + 1
        
        # Facies naming logic
        facies_title = "FT-0" * f[2:end]
        # else
        #     f
        # end

        # Axis labeling logic
        x_label = row == cld(length(u_facies), 2) ? "Time (days)" : ""
        y_label = col == 1 ? "Concentration (mol kg⁻¹)" : ""
        
        ax = Axis(fig[row, col], 
                  title = "$(letters[i]). $facies_title", 
                  titlealign = :left,
                  titlesize = 14,
                  titlefont = "Avenir Book", # or just Bold
                  titlecolor = fontcolor,
                  xlabel = x_label, 
                  ylabel = y_label,
                  xlabelsize = 14,
                  ylabelsize = 14,
                  xlabelcolor = fontcolor,
                  ylabelcolor = fontcolor,
                  xticklabelsize = 12,
                  yticklabelsize = 12,
                  xticklabelcolor = fontcolor,
                  yticklabelcolor = fontcolor,
                  xticklabelfont = "Avenir Book",
                  yticklabelfont = "Avenir Book",
                  xlabelfont = "Avenir Book",
                  ylabelfont = "Avenir Book",
                  xgridvisible = false,
                  ygridvisible = true,
                  xgridcolor = (:grey64, 0.6),
                  ygridcolor = (:grey64, 0.6),
                  backgroundcolor = :transparent,
                  limits = (facies_title == "FT-07") & (experiment == 'A') ? ((-2, 126), (0, 0.20)) : ((-2, 126), (0, 0.093)),
                  xticksvisible = row == cld(length(u_facies), 2),
                  xticklabelsvisible = row == cld(length(u_facies), 2),
                  yticksvisible = true,
                  yticklabelsvisible = true,
                  width = 300,
                  height = 150,
                  xticks = 0:25:175,
                  yticks = (facies_title == "FT-07") & (experiment == 'A') ? (0:0.02:0.20) : (0:0.01:0.20),
                  leftspinecolor = fontcolor,
                  rightspinecolor = fontcolor,
                  topspinecolor = fontcolor,
                  bottomspinecolor = fontcolor,
                  xgridwidth = 0.7,
                  ygridwidth = 0.7
                  )
        axes[f] = ax
    end
    return axes
end

axes_A = create_facies_axes(figure_A, unique_facies_A, letters, 'A')
axes_B = create_facies_axes(figure_B, unique_facies_B, letters, 'B')

# Borehole markers for Experiment A
boreholes = unique([s[1:2] for s in exp_A_samples.Sample])
markers = [:circle, :rect, :dtriangle, :diamond, :utriangle, :pentagon, :hexagon]
borehole_markers = Dict(zip(boreholes, markers[1:length(boreholes)]))

# Legend elements for Experiment A
leg_elements_A = []
# Chemical species
push!(leg_elements_A, [LineElement(color = colors[1], linestyle = :solid), MarkerElement(color = colors[1], marker = :circle, markersize = 8)])
push!(leg_elements_A, [LineElement(color = colors[2], linestyle = :solid), MarkerElement(color = colors[2], marker = :circle, markersize = 8)])
leg_labels_A = ["NO₃⁻", "DOC"]
# Boreholes
for bh in boreholes
    push!(leg_elements_A, MarkerElement(color = colors[1], marker = borehole_markers[bh], markersize = 8))
    push!(leg_labels_A, bh)
end

# Legend for Experiment A
Legend(figure_A[cld(length(unique_facies_A), 2) + 1, 1:2], leg_elements_A, leg_labels_A, framevisible = false, orientation = :horizontal, labelsize = 14, labelcolor = fontcolor, labelfont = "Avenir Book", backgroundcolor = :transparent, nbanks = 2)

# Legend elements for Experiment B
leg_elements_B = [
    [LineElement(color = colors[1], linestyle = :solid), MarkerElement(color = colors[1], marker = :circle, markersize = 8)],
    [LineElement(color = colors[2], linestyle = :solid), MarkerElement(color = colors[2], marker = :circle, markersize = 8)],
    # [LineElement(color = colors[3], linestyle = :solid), MarkerElement(color = colors[3], marker = :circle, markersize = 8)]
]
leg_labels_B = ["NO₃⁻", "DOC",] #"SO₄²⁻"]
# Legend for Experiment B
Legend(figure_B[cld(length(unique_facies_B), 2) + 1, 1:2], leg_elements_B, leg_labels_B, framevisible = false, orientation = :horizontal, labelsize = 14, labelcolor = fontcolor, labelfont = "Avenir Book", backgroundcolor = :transparent)

# Facies counts
facies_counts_A = Dict{String, Int}()
facies_counts_B = Dict{String, Int}()

for i in 1:total_plots
    sample = samples[i]
    facies = df_info[df_info[!, :Sample] .== sample, "Facies new"][1]
    # if sample[1] == 'A' && facies == "C2"
    #     facies = "C1"
    # end
    mass = df_info[df_info[!, :Sample] .== sample, "dry weight (g)"][1] # g
    mass = mass * 1e-3 # convert to kg
    df = CSV.read(datadir("exp_pro","$sample.csv"), DataFrame)
    # t_change_i = t_change[i]
    all_times = df[!, :t]
    modelled_no3 = df[!, "NO3-"]
    index_no3 = convert.(Bool, 1 .-(ismissing.(modelled_no3)))
    index_no3 = findall(index_no3) # indices of non-missing NO₃⁻ values
    #modelled_no3 = modelled_no3[index_no3].*1e-3 # convert to mol L⁻¹
    modelled_times = all_times[index_no3]
    data_fit = LinearInterpolation(modelled_no3[index_no3].*1e-3, modelled_times; extrapolation = ExtrapolationType.Constant)
    
    doc = df[!, "DOC"]
    index_doc = convert.(Bool, 1 .-(ismissing.(doc)))
    index_doc = findall(index_doc) # indices of non-missing DOC values
    #doc = doc[index_doc].*1e-3 # convert to mol L⁻¹
    doc_times = all_times[index_doc]
    doc_fit = LinearInterpolation(doc[index_doc].*1e-3, doc_times; extrapolation = ExtrapolationType.Constant)
    # correct for the reduction in water volume due to sample extraction
    vws = Vw * ones(size(all_times))
    volume_removed = 0.005 * ones(size(all_times)) # L: volume removed for analysis (5 ml)
    mass_removed = data_fit.(all_times) .* volume_removed # mols: mass of NO₃⁻ removed at each time point
    doc_removed = doc_fit.(all_times) .* volume_removed # mols: mass of DOC removed at each time point
    cum_vol_removed = cumsum(volume_removed)
    cum_mass_removed = cumsum(mass_removed) # mols: cumulative mass of NO₃⁻ removed
    cum_doc_removed = cumsum(doc_removed) # mols: cumulative mass of DOC removed
    vws = Vw .- cum_vol_removed
    no3_mol_kg = zeros(length(modelled_times)) # preallocate for NO₃⁻ mol kg⁻¹
    k = 1
    for ind in index_no3
        if ind == 1
            no3_mol_kg[1] = modelled_no3[ind]*1e-3 .* 0.08 ./ mass # convert to mol kg⁻¹
        else
            no3_mol_kg[k] = (modelled_no3[ind]*1e-3 .* vws[ind-1] + cum_mass_removed[ind-1]) ./ mass # convert to mol kg⁻¹
        end
        k += 1
    end
    doc_mol_kg = zeros(length(doc_times)) # preallocate for DOC mol kg⁻¹
    k = 1
    for ind in index_doc
        if ind == 1
            doc_mol_kg[1] = doc[ind]*1e-3 .* 0.08 ./ mass # convert to mol kg⁻¹
        else
            doc_mol_kg[k] = (doc[ind]*1e-3 .* vws[ind-1] + cum_doc_removed[ind-1]) ./ mass # convert to mol kg⁻¹
        end
        k += 1
    end
    if sample[1] == 'B' # then we also have sulfate data
        so4 = df[!, "SO4-2"]
        index_so4 = convert.(Bool, 1 .-(ismissing.(so4)))
        index_so4 = findall(index_so4) # indices of non-missing SO₄²⁻ values
        so4_times = all_times[index_so4]
        so4_mol_kg = zeros(length(so4_times)) # preallocate for SO₄²⁻ mol kg⁻¹
        so4_fit = LinearInterpolation(so4[index_so4].*1e-3, so4_times; extrapolation = ExtrapolationType.Constant)
        so4_removed = so4_fit.(all_times) .* volume_removed # mols: mass of SO₄²⁻ removed at each time point
        cum_so4_removed = cumsum(so4_removed) # mols: cumulative mass of SO₄²⁻ removed
        k = 1
        for ind in index_so4
            if ind == 1
                so4_mol_kg[1] = so4[ind]*1e-3 .* 0.08 ./ mass # convert to mol kg⁻¹
            else
                so4_mol_kg[k] = (so4[ind]*1e-3 .* vws[ind-1] + cum_so4_removed[ind-1]) ./ mass # convert to mol kg⁻¹
            end
            k += 1
        end
    end

    # Now I need to define when the experiment became zero-order.
    # I will interpolate the corrected DOC data and then find the time when it crosses the line
    # that represent the constant DOC value (average of the last 2 DOC values).
    # This is when we interpret the experiment as zero-order because the NO₃⁻ reduction is then
    # not limited by the DOC concentration anymore, but to the matrix hydrolysis of e- donors.
    no3_fit = LinearInterpolation(no3_mol_kg, modelled_times; extrapolation = ExtrapolationType.Constant)
    doc_fit = LinearInterpolation(doc_mol_kg, doc_times; extrapolation = ExtrapolationType.Constant)
    # find the last two DOC values and calculate the average
    doc_last_two = doc_mol_kg[end-2:end]
    doc_avg = mean(doc_last_two)
    # find the time when the DOC concentration crosses the average
    t_change_i = findfirst(doc_fit.(all_times) .<= doc_avg)
    if t_change_i === nothing
        t_change_i = length(all_times) # if it never crosses, then we take the last time point
    end
    t_change = all_times[t_change_i] # convert to time
    # handpicking a few samples where my automated criteria did not work
    if sample == "A908" # potential bad_t_change
        global t_change = 100.0
    elseif sample == "A509" # potential bad_t_change
        global t_change = 50.0
    elseif sample == "A508" # potential bad_t_change
        global t_change = 30.0
    elseif sample == "A301" # potential bad_t_change
        global t_change = 50.0  
    end
    println("Sample: $(sample), t_change: $(t_change)")
    # calculate the slope of the NO₃⁻ reduction
    # Linear regression:
    X = [ones(size(modelled_times[modelled_times.>t_change])) modelled_times[modelled_times.>t_change]]
    y = no3_mol_kg[modelled_times.>t_change]
    # linear regression and model fit results:
    β = (X'X)\(X'y)
    ϵ = y - X*β
    s² = ϵ'ϵ/(length(y)-length(β))
    σ² = s²*(length(y)-length(β))/length(y)
    ȳ = mean(y)
    SST = sum((y .- ȳ).^2)
    SSR = sum(ϵ.^2)
    R² = 1 - SSR/SST
    r_no3 = -β[2] # slope of the NO₃⁻ reduction
    c0_model = β[1] # initial concentration of NO₃⁻
    model_no3(t) = c0_model - r_no3*t
    # calculate when data intercepts the model:
    println("Sample: $(sample)")

    t_of_zero = t_change > 0 ? find_zeros(t-> no3_fit(t)-model_no3(t), 0, 150)[1] : 0.0
    # calculate and plot the integral using Trapz
    integral_no3 = quadgk(no3_fit, 0.0, t_of_zero)[1]
    c0_data = no3_fit(0.0) # initial concentration
    c_quick = t_change > 0 ? c0_data - c0_model : 0.0

    integral_function = quadgk(model_no3, 0.0, t_of_zero)[1]
    # trapz(times_n, model_no3.(times_n))
    resulting_integral = (integral_no3 - integral_function)
   
    t_quick = t_change > 0 ? resulting_integral/c_quick : 0.0
    
    # Simple decrease calculation (Day 0 to Day 125 or closest)
    c125_data = no3_fit(125.0)
    decrease_125 = c0_data - c125_data
    decrease_pct_125 = (c0_data - c125_data) / c0_data * 100

    # DOC decrease calculation
    doc_c0_data = doc_fit(0.0)
    doc_c125_data = doc_fit(125.0)
    doc_decrease_125 = doc_c0_data - doc_c125_data
    doc_decrease_pct_125 = (doc_c0_data - doc_c125_data) / doc_c0_data * 100

    # Collect corrected data for export
    # Create vectors of missing/float for the full time range
    n_times = length(all_times)
    no3_corr_full = Vector{Union{Missing, Float64}}(missing, n_times)
    no3_corr_full[index_no3] .= no3_mol_kg

    doc_corr_full = Vector{Union{Missing, Float64}}(missing, n_times)
    doc_corr_full[index_doc] .= doc_mol_kg

    so4_corr_full = Vector{Union{Missing, Float64}}(missing, n_times)
    if sample[1] == 'B'
        so4_corr_full[index_so4] .= so4_mol_kg
    end

    sample_corrected_df = DataFrame(Time = all_times,
                                    NO3_corrected = no3_corr_full,
                                    DOC_corrected = doc_corr_full,
                                    SO4_corrected = so4_corr_full)
    push!(data_for_excel, sample => sample_corrected_df)

    # Collect data for facies aggregation excel
    facies_agg_df = copy(sample_corrected_df)
    insertcols!(facies_agg_df, 1, :Sample => sample)
    
    exp_label = startswith(sample, "A") ? "ExpA" : "ExpB"
    sheet_name = "$(exp_label)_$(facies)"
    
    if haskey(facies_data_collection, sheet_name)
        append!(facies_data_collection[sheet_name], facies_agg_df)
    else
        facies_data_collection[sheet_name] = facies_agg_df
    end

    # facies defined at start of loop
    TOC = df_info[df_info[!, :Sample] .== sample, "TOC %"][1]
    S_tot = df_info[df_info[!, :Sample] .== sample, "S_tot %"][1]
    if sample[1] == 'B' # then we also have sulfate data
        X = [ones(size(modelled_times)) modelled_times]
        y = so4_mol_kg
        # linear regression and model fit results:
        β = (X'X)\(X'y)
        ϵ = y - X*β
        s² = ϵ'ϵ/(length(y)-length(β))
        σ² = s²*(length(y)-length(β))/length(y)
        ȳ = mean(y)
        SST = sum((y .- ȳ).^2)
        SSR = sum(ϵ.^2)
        #R² = 
        so4_fit(t) = β[1] + β[2]*t
        so4_c0 = β[1]
        so4_r = β[2]
        R²so4 = 1 - SSR/SST
    else
        so4_c0 = missing
        so4_r = missing
        R²so4 = missing
    end
    push!(late_times_params, [sample, facies, r_no3, c0_model, R², t_change, 
                              resulting_integral, c_quick, t_quick,
                              mass, TOC, S_tot,
                              so4_c0, so4_r, R²so4,
                              decrease_125, decrease_pct_125,
                              doc_decrease_125, doc_decrease_pct_125])

    # Count samples per facies
    counts_dict = sample[1] == 'A' ? facies_counts_A : facies_counts_B
    counts_dict[facies] = get(counts_dict, facies, 0) + 1

    # Add to specific experiment/facies plot
    current_axes = sample[1] == 'A' ? axes_A : axes_B
    if haskey(current_axes, facies)
        ax_f = current_axes[facies]
        
        # Determine marker
        marker_shape = :circle
        if sample[1] == 'A'
             marker_shape = borehole_markers[sample[1:2]]
        end

        lines!(ax_f, modelled_times, no3_mol_kg, color = colors[1], linewidth = 1.5)
        scatter!(ax_f, modelled_times, no3_mol_kg, color = colors[1], marker = marker_shape, markersize = 10)
        
        lines!(ax_f, doc_times, doc_mol_kg, color = colors[2], linewidth = 1.5)
        scatter!(ax_f, doc_times, doc_mol_kg, color = colors[2], marker = marker_shape, markersize = 10)
        
        # if sample[1] == 'B'
        #      lines!(ax_f, so4_times, so4_mol_kg, color = colors[3], linewidth = 1.5)
        #      scatter!(ax_f, so4_times, so4_mol_kg, color = colors[3], marker = marker_shape, markersize = 10)
        # end
    end

    # 2 cols and 4 rows
    grid_plot_num = ceil(Int, i/8)
    grid_pos = ceil(Int, (i-1) % 8) + 1
    grid_plot_row =   ceil(Int, grid_pos/2)
    grid_plot_col = grid_pos % 2 == 0 ? 2 : 1
    ax = Axis(grid_plot_figs[grid_plot_num][grid_plot_row, grid_plot_col], xlabel = "Time (days)", ylabel = "Concentration (mol kg⁻¹)",
    title = "$(sample) - facies: $(facies)",
    #xticks = 0:10:170, yticks = 0:0.5:4,
    xgridstyle = :dash, ygridstyle = :dash,
    #xgridwidth = 0.4, ygridwidth = 0.4,
    )
    ylims!(ax, (0, 3.8e-3*Vw/mass)) # mol kg⁻¹
    xlims!(ax,(-2, 180))
    if t_change > 0
            tfill = 0:0.1:t_of_zero
            fill_between!(ax, tfill, model_no3.(tfill),
                no3_fit.(tfill), color = colors[1], alpha = 0.5)
    end
    lines!(ax, all_times, model_no3.(all_times), color = colors[1], label = "Model NO3-")
    scatter!(ax, modelled_times, no3_mol_kg, color = colors[1], label = meas_names[1])
    scatter!(ax, doc_times, doc_mol_kg, color = colors[2], label = meas_names[2])
    if sample[1] == 'B' # then we also have sulfate data
        scatter!(ax, so4_times, so4_mol_kg, color = colors[3], label = meas_names[3])
    end
    text!(ax, 0.5, 0.9,
        text="R² = $(round(R², digits=2))",
        color = :black, space = :relative)
    Legend(grid_plot_figs[grid_plot_num][5,1:2], ax, "Substance", merge = true, framevisible = false, orientation = :horizontal)
    #Label(grid_plot_figs[grid_plot_num][1,1:2, Top()], "Normalized NO3- and DOC plots", fontsize = 18, halign = :center)
end

# Add sample counts text to plots
for (facies, count) in facies_counts_A
    if haskey(axes_A, facies)
        upper_limit = facies == "T7" ? 0.20 : 0.093
        text!(axes_A[facies], 125/2-5, upper_limit, text = "n=$count", align = (:center, :top), fontsize = 12, font = "Avenir Book", color = fontcolor)

        # Add avg TOC text
        current_facies_df = filter(row -> row.facies == facies && startswith(row.sample, "A"), late_times_params)
        if !isempty(current_facies_df)
            mean_toc = mean(skipmissing(current_facies_df.TOC))
            text!(axes_A[facies], 120, upper_limit, text = "mean SOC: $(round(mean_toc, digits=1))%", align = (:right, :top), fontsize = 12, font = "Avenir Book", color = fontcolor)
        end
    end
end
for (facies, count) in facies_counts_B
    if haskey(axes_B, facies)
        upper_limit = 0.093
        text!(axes_B[facies], 125/2-5, upper_limit, text = "n=$count", align = (:center, :top), fontsize = 12, font = "Avenir Book", color = fontcolor)

        # Add avg TOC text
        current_facies_df = filter(row -> row.facies == facies && startswith(row.sample, "B"), late_times_params)
        if !isempty(current_facies_df)
            mean_toc = mean(skipmissing(current_facies_df.TOC))
            text!(axes_B[facies], 120, upper_limit, text = "mean SOC: $(round(mean_toc, digits=1))%", align = (:right, :top), fontsize = 12, font = "Avenir Book", color = fontcolor)
        end
    end
end

[resize_to_layout!(grid_plot_figs[i]) for i in 1:grid_plots]
[save(plotsdir("grid_plot_$(i).png"), grid_plot_figs[i], px_per_unit = 400/inch) for i in 1:grid_plots]
[save(plotsdir("grid_plot_$(i).pdf"), grid_plot_figs[i], px_per_unit = 400/inch) for i in 1:grid_plots]
resize_to_layout!(figure_A)
save(plotsdir("experiment_A_facies.png"), figure_A)
save(plotsdir("experiment_A_facies.pdf"), figure_A)
resize_to_layout!(figure_B)
save(plotsdir("experiment_B_facies.png"), figure_B)
save(plotsdir("experiment_B_facies.pdf"), figure_B)
CSV.write(datadir("exp_pro","linear_regression_params_v2.csv"), late_times_params)
XLSX.writetable(datadir("exp_pro", "corrected_data_by_sample.xlsx"), data_for_excel, overwrite=true)

# Prepare for XLSX facies aggregation (Mean ± Std)
facies_stats_sheets = Vector{Pair{String, DataFrame}}()

for (sheet_name, df_raw) in facies_data_collection
    # Group by Time
    gdf = groupby(df_raw, :Time)
    
    # Custom aggregation functions
    function calc_mean(x)
        v = collect(skipmissing(x))
        return isempty(v) ? missing : mean(v)
    end
    
    function calc_std(x)
        v = collect(skipmissing(x))
        return length(v) < 2 ? missing : std(v)
    end
    
    # Aggregate
    stats_df = combine(gdf,
        :NO3_corrected => calc_mean => :NO3_mean,
        :NO3_corrected => calc_std => :NO3_std,
        :DOC_corrected => calc_mean => :DOC_mean,
        :DOC_corrected => calc_std => :DOC_std,
        :SO4_corrected => calc_mean => :SO4_mean,
        :SO4_corrected => calc_std => :SO4_std
    )
    
    # Sort by time
    sort!(stats_df, :Time)
    
    push!(facies_stats_sheets, sheet_name => stats_df)
end

sort!(facies_stats_sheets, by = x -> x.first) # Sort by sheet name
XLSX.writetable(datadir("exp_pro", "corrected_data_by_facies.xlsx"), facies_stats_sheets, overwrite=true)


# Function to plot percentage decrease
function plot_decrease_stats(stats_df, exp_label, substance="Nitrate")
    # Prepare data for plotting
    n_facies = nrow(stats_df)
    facies_names = stats_df.facies
    medians = stats_df.median_decrease_pct
    stds = replace(stats_df.std_decrease_pct, NaN => 0.0) # Handle NaN for single samples

    fig = Figure(size = (800, 600))
    ax = Axis(fig[1, 1], 
              xlabel = "Facies", 
              ylabel = "Decrease after 125 days (%)",
              title = "Experiment $exp_label: $substance Decrease (Direct Calculation)",
              xticks = (1:n_facies, facies_names))
    
    barplot!(ax, 1:n_facies, medians, 
             color = :steelblue, 
             strokecolor = :black, strokewidth = 1)
    
    errorbars!(ax, 1:n_facies, medians, stds, 
               whiskerwidth = 10, color = :black)
    
    safe_substance = replace(substance, " " => "_")
    save(plotsdir("experiment_$(exp_label)_$(safe_substance)_decrease_125d_pct.png"), fig)
    save(plotsdir("experiment_$(exp_label)_$(safe_substance)_decrease_125d_pct.pdf"), fig)
end

for (exp_label, df_exp) in [("A", filter(row -> startswith(row.sample, "A"), late_times_params)), 
                            ("B", filter(row -> startswith(row.sample, "B"), late_times_params))]
    
    # --- NO3 Stats ---
    stats_exp = combine(groupby(df_exp, :facies), 
                        :decrease_125 => median => :median_decrease, 
                        :decrease_125 => std => :std_decrease,
                        :decrease_pct_125 => median => :median_decrease_pct,
                        :decrease_pct_125 => std => :std_decrease_pct)
    
    sort!(stats_exp, :facies)
    
    println("\nExperiment $exp_label Stats (NO3 Decrease after 125 days - Direct):")
    display(stats_exp)
    
    CSV.write(datadir("exp_pro", "experiment_$(exp_label)_stats_125d.csv"), stats_exp)
    plot_decrease_stats(stats_exp, exp_label, "Nitrate")

    # --- DOC Stats ---
    stats_doc = combine(groupby(df_exp, :facies), 
                        :doc_decrease_125 => median => :median_decrease, 
                        :doc_decrease_125 => std => :std_decrease,
                        :doc_decrease_pct_125 => median => :median_decrease_pct,
                        :doc_decrease_pct_125 => std => :std_decrease_pct)
    
    sort!(stats_doc, :facies)
    
    println("\nExperiment $exp_label Stats (DOC Decrease after 125 days - Direct):")
    display(stats_doc)
    
    CSV.write(datadir("exp_pro", "experiment_$(exp_label)_doc_stats_125d.csv"), stats_doc)
    plot_decrease_stats(stats_doc, exp_label, "DOC")
end
